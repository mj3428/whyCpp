# 变量与基本类型
## 变量
### 变量定义
初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义时把对象的当前值擦除，而以一个新值来替代。  
*例* double salary = wage = 9999.99;  
♥在这里 wage 是未定义的，应该在此之前将其定义。  
```
double wage;
double salary = wage = 9999.99;
```
另外提示:
> 使用未初始化的变量将带来无法预计的后果，有时我们足够幸运，以访问此类对象程序就崩溃并报错，此时只要找到崩溃的位置就很容易发现变量没被
初始化的问题。另外一些时候，程序会一直执行完并产生错误的结果。更糟糕的是，程序结果时对时错、无法把握。而且，往无关的位置添加代码还会导致
我们误以为程序对了，其实结果仍旧有错。  

### 变量声明和定义的关系
C++语言支持分离式编译机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。为了支持分离式编译，C++语言将声明和定义区分开来。**声明
（declaration）** 使得名字为程序所知，一个文件如果想使用别处定义的名字就必须包含对那个名字的声明。而**定义**负责创建与名字关联的实体。  
1. 变量声明规定了变量的类型和名字，在这一点上定义与之相同。  
2. 但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。  
关键字**extern** 是只声明而非定义。
```
extern int j;  // 声明i而非定义i
int j; //  声明并定义j
```
但是如果extern语句如果包含初始值就不再是声明，而变成了定义了:
`extern double pi = 3.1415; // 定义`  

⭐ 变量能且只能被定义一次，但是可以被多次声明  

⭐ C++是一种静态类型语言，其含义是在编译阶段检查类型。其中，检查类型的过程成为类型检查(type checking)

## 复合类型
### 指针
pointer是“指向point to”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。  
1. 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。  
2. 指针无须再定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。
#### 获取对象的地址
指针存放某个对象的地址，要想获取该地址，需要使用取地址符(操作符&):
`int *p = &ival;  // p存放变量ival的地址，或者说p是指向变量ival的指针`首先把p定义为一个指向int的指针，随后初始化p令其指向
名为ival的int对象。因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。  
其他所有指针的类型都要和它所指向的对象严格匹配:
```cpp
double dval;
double *pd = &dval; //  正确：初始值是double型对象的地址
double *pd2 = pd; //  正确：初始值是指向double对象的指针

int *pi = pd; //  错误:指针pi的类型和pd的类型不匹配
pi = &dval； //  错误:试图把double型对象的地址赋给int型指针
```
#### 利用指针访问对象
如果指针指向了一个对象，则允许使用**解引用符(操作符*)** 来访问该对象:
```
int ival = 42;
int *p = &ival; //  p存放着变量ival的地址，或者说p是指向变量ival的指针
cout << *p; //  由符号*得到指针p所指的对象，输出42
```
**关键概念**  
```cpp
//像&和*这样的符号,既能用作表达式里的运算符,也能作为声明的一部分出现,符号的上下文决定了符号的意义:

int i = 42;
int &r = i; //  &紧随类型名出现，因此是声明的一部分，r是一个引用
int *p; //  *紧随类型名出现，因此是声明的一部分，p是一个指针
p = &i; //  &出现在表达式中，是一个取地址符
*p = i; //  *出现在表达式中，是一个解引用符
int &r2 = *p; //  &是声明的一部分，*是一个解引用符
```
**建议：初始化所有指针**
> 在大多数编译器环境下,如果使用了未经初始化的指针,则该指针所占内存空间的当前内容将被看作一个地址值。访问该指针,相当于
去访问一个本不存在的位置上的本不存在的对象。糟糕的是,如果指针所占内存空间中恰好有内容,而这些内容又被当作了某个地址,我们就很难
分清它到底是合法的还是非法的了。  

#### 赋值和指针
指针和引用都能提供对其他对象的间接访问,然而在具体实现细节上二者有很大不同,其中最重要的一点就是引用本身并非一个对象。一旦定义了引
用,就无法令其再绑定到另外的对象,之后每次使用这个引用都是访问它最初绑定的那个对象。  
```cpp
int i = 42
int *pi = 0;  //  pi被初始化，但没有指向任何对象
int *pi2 = &i;  //  pi2被初始化，存有i的地址
int *pi3; //  如果pi3定义于块内，则pi3的值是无法确定的

pi3 = pi2 // pi3和pi2指向同一个对象i
pi2 = 0 //  现在pi2不指向任何对象了
```
有时候要想搞清楚一条赋值语句到底是改变了指针的值还是改变了指针所指对象的值不太容易，最好的办法就是记住赋值永远改变的是等号左侧的对象。  
比如:`pi = &ival; //  pi的值被改变，现在pi指向了ival`意思是为pi赋一个新值，也就是改变了哪个存放在pi内的地址值  
再如:`*pi = 0;  //  ival的值被改变，指针pi并没有改变`则`*pi`(也就是指针Pi指向的哪个对象)发生改变  
#### 其他指针操作
只要指针拥有一个合法值，就能将它用在条件表达式中。和采用算术值作为条件false:
```cpp
int ival = 1024;
int *pi = 0;  //  pi合法，是一个空指针
int *pi2 = &ival; //  pi2是一个合法的指针，存放着ival的地址
if (pi) //  pi的值是0，因此条件的值是false
  //  ...
if (pi2)  //  pi2指向ival，因此它的值不是0，条件的值是true
  //  ...
```
#### void* 指针
`void*`是一种特殊的指针类型，可用于存放任意对象的地址。一个 void* 指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底
是个什么类型的对象并不了解:
```cpp
double obj = 3.14, *pd = &obj;  //  正确:void*能存放任意类型对象的地址
void *pv = &obj;  //  obj可以是任意类型的对象
pv = pd;  //  pv可以存放任意类型的指针
```
#### 总结(指针)
⭐**引用与指针的区别!!!**   
1. 引用是另一个对象的别名，而指针本身就是一个对象。  
2. 引用必须初始化，并且一旦定义了引用就无法再绑定到其他对象。而指针无须在定义时赋初值，也可以重新赋值让其指向其他对象。  

> 假设 p 是一个 int 型指针，请说明下述代码的含义。
```cpp
if (p) // ...
if (*p) // ...
```
`if (p) // ... 判断 p 是不是一个空指针, if (*p) // ... 判断 p 所指向的对象的值是不是为 0`

### 理解复合类型的说明
很多程序员容易迷惑于基本数据类型和类型修饰符的关系,其实后者不过是声"明符的一部分罢了。  
#### 定义多个变量
经常有一种观点会误以为，再定义语句种，类型修饰符(`*` 或 `&` )作用于本次定义的全部变量。造成这种错误看法的原因有很多，其中之一是我们可以把空格
写在类型修饰符和变量名中间:`int* p;  //  合法但是容易产生误导`我们说这种写法可能产生误导是因为`int*`放在一起好像是这条语句中的所有变量共同
类型一样。其实恰恰相反，基本数据类型是int而非`int*`。 `*`仅仅是修饰了p而已，对该声明语句中的其他变量，它并不产生任何作用:`int* p1,p2;  //
p1是指向int的指针，p2是Int`
#### 指向指针的指针
通过`*`的个数可以区分指针的级别。也就是说，`**`表示指向指针的指针，`***`表示指向指针的指针的指针，以此类推:
```cpp
int ival = 1024;
int *pi = &ival;  //  pi指向一个int型的数
int **ppi = &pi;  //  ppi指向一个Int型的指针
```
#### 指向指针的引用
引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用:
```
int i = 42; 
int *p; //  p时一个int型指针
int *&r = p;  //  r是一个对指针P的引用,按照从右往左的方法。离变量最近为最直接判定，所以r最近为&,r是一个引用

r = &i; //  r引用了一个指针，因此给r赋值&i就是令p指向i
*r = 0; //  解引用r得到i，也就是P指向的对象，将i的值改为0
```
## const限定符
因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。一如既往，初始值可以是任意复杂的表达式:
```cpp
const int i = get_size(); //  正确：运行时初始化
const int j = 42; //  正确:编译时初始化
const int k;  //  错误:k是一个未经初始化的常量
```
**默认状态下，const对象仅在文件内有效** 如果程序包含多个文件，则每个用了const对象的文件都必须得能访问到它的初始值才行。要做到
这点，就必须再每个用到变量的文件中都有对它的定义。**但是要在其他文件访问也是可以做到的，即添加extern关键字**   
```cpp
//  file_1.cc定义并初始化了一个常量，该常量能被其他文件访问
extern const int bufSize = fcn();
//  file_1.h 头文件
extern const int bufSize; //  与file_1.cc中定义的bufSize是同一个
```
因为bufSize是一个常量，必须用extern加以限定被其他文件使用。  
### const的引用
可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为**对常量的引用(reference to const)**   
```cpp
const int ci = 1024;
const int &r1 = ci; //  正确:引用及其对应的对象都是常量
int &r2 = ci; //  错误:试图让一个非常量引用指向一个常量对象
```
#### 初始化和对const引用
**引用的类型必须与引用对象的类型一致** ,但是有两个例外。第一种例外情况就是再初始化常量引用时允许用任意表达式作为初始值，只要表达式的结果能
转换成引用的类型即可。
```cpp
int i = 42;
const int &r1 = i;  //  允许将const int&绑定到一个普通int对象上
const int &r2 = 42; //  正确:r1是一个常量引用
const int &r3 = r1 * 2; //  正确:r3是一个常量引用
int &r4 = r1 * 2; //  错误:r4是一个普通的非常量引用
```
### 指针和const
指向常量的指针不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针:
```cpp
const double pi = 3.14; //  pi是个常量，它的值不能改变
double *ptr = &pi;  //  错误:ptr是一个普通指针
const double *cptr = &pi; //  正确:ctpr可以指向一个双精度常量
*cptr = 42  //  错误：不能给*cptr赋值
```
#### const指针
```cpp
int errNumb = 0;
int *const curErr = &errNumb; //  curErr将一直指向errNumb
const double pi = 3.14159;
const double *const pip = &pi;  //  pip是一个指向常量对象的常量指针
```
> 说明下面的这些定义是什么意思，挑出其中不合法的
```cpp
int i, *const cp;       // 不合法, const 指针必须初始化
int *p1, *const p2;     // 不合法, const 指针必须初始化
const int ic, &r = ic;  // 不合法, const int 必须初始化
const int *const p3;    // 不合法, const 指针必须初始化
const int *p;           // 合法. 一个指针，指向 const int
```

> 假设已有上一个练习中定义的那些变量，则下面的哪些语句是合法的？请说明原因。
```cpp
i = ic;     // 合法, 常量赋值给普通变量
p1 = p3;    // 不合法, p3 是const指针不能赋值给普通指针
p1 = &ic;   // 不合法, 普通指针不能指向常量
p3 = &ic;   // 合法, p3 是常量指针且指向常量
p2 = p1;    // 合法, 可以将普通指针赋值给常量指针
ic = *p3;   // 合法, 对 p3 取值后是一个 int 然后赋值给 ic
```
### 顶层const
比较特殊的是，指针类型既可以是顶层const也可以是底层const，这一点和其他类型相比区别明显:
```cpp
int i = 0;
int *const p1 = &i; //  不能改变p1的值，这是一个顶层const
const int ci = 42;  //  不能改变ci的值，这是一个顶层const
const int *p2 = &ci;  //  允许改变p2的值，这是一个底层const
const int *const *p3 = p2;  //  靠右的const是顶层const,靠左的是底层const
const int &r = ci;  //  用于声明引用的const都是底层const
```
当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。其中，顶层的const不受什么影响:
```cpp
i = ci; //  正确：拷贝ci的值，ci是一个顶层const，对此操作无影响
p2 = p3;  //  正确:p2和p3指向的对象类型相同，p3顶层const的部分不影响
```
另一方面,底层const的限制却不能忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够
转换。一般来说，非常量可以转换成常量，反之则不行：
```cpp
int *p = p3;  //  错误:p3包含底层const的定义，而p没有
p2 = p3;  //  正确:p2和p3都是底层const
p2 = &i;  //  正确:int*能转换成const int*
int &r = ci;  //  错误:普通的int&不能绑定到int常量上
const int &r2 = i;  //  正确:const int&可以绑定到一个普通Int上
```
> 对于下面的这些语句，请说明对象被声明成了顶层const还是底层const？
```cpp
const int v2 = 0; int v1 = v2;
int *p1 = &v1, &r1 = v1;
const int *p2 = &v2, *const p3 = &i, &r2 = v2;
```
v2 是顶层const(不能改变v2的值)，p2 是底层const，p3 既是顶层const又是底层const，r2 是底层const。
### constexpr和常量表达式
**常量表达式** 是指值不会改变并且在编译过程就能得到计算结果的表达式。显然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量
表达式。  
```cpp
const int max_files = 20; //  max_files是常量表达式
const int limit = max_files + 1;  //  limit是常量表达式
int staff_size = 27;  //  staff_size不是常量表达式
const int sz = get_size();  //  sz不是常量表达式
```
#### constexpr变量
允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化:
```cpp
constexpr int mf = 20;  //  20时常量表达式
constexpr int limit = mf + 1; //  mf+1是常量表达式
constexpr int sz = size();  //  只有当size是一个constexpr函数时才是一条正确的声明语句
```
#### 指针和constexpr
必须明确一点，在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关:
```cpp
const int *p = nullptr; //  p是一个指向整型常量的指针
constexpr int *q = nullptr; //  q是一个指向整数的常量指针
```
p和q的类型相差甚远，p是一个指向常量的指针，而q是一个常量指针，其中的关键在于constexpr把它所定义的对象置为了顶层const。  
## 处理类型
### 类型别名
新标准规定了一种新的方法，使用别名声明来定义类型的别名:`using SI = Sales_item; //  SI是Sales_item的同义词`这种方法用关键字
using作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成符号右侧类型的别名。
#### 指针、常量和类型别名
如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。例如下面的声明语句用到了类型pstring，它实际上是
类型`char*`的别名:
```cpp
tyoedef char *pstring;
const pstring cstr = 0; //  cstr是指向char的常量指针
const pstring *ps;  //  ps是一个指针，它的对象是指向char的常量指针
```
pstring实际上是指向char的指针，因此，const pstring就是zhixiangchar的常量指针，而非指向常量字符的指针。  
### auto类型说明符
自动判断类型
```cpp
auto i = 0, *p = &i;  //  正确:i是整数，p是整型指针
auto sz = 0, pi = 3.14; //  错误:sz和pi的类型不一致
```
使用引用其实是使用引用的对象，特别是当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型：
```cpp
int i = 0, &r = i;
auto a = r; //  a是一个整数(r是i的别名，而i是一个整数)
```
其次，auto一般会忽略掉顶层const，同时底层const则会保留下来，比如当初始值时一个指向常量的指针时:
```cpp
const int ci = i, &cr = ci;
auto b = ci;  //  b是一个整数(ci的顶层const特性被忽略掉了)
auto c = cr;  //  c是一个整数(cr是ci的别名，ci本身又是一个顶层const)
auto d = &i;  //  d是一个整型指针（整数的地址就是指向整数的指针）
auto e = &ci; //  e是一个指向整数常量的指针（对常量对象取地址是一种底层const）
```
如果希望推断出的auto类型是一个const，需要明确指出:
```cpp
auto &g = ci; // g是一个整型常量引用，绑定到ci
auto &h = 42; //  错误:不能为非常量引用绑定字面值
const auto &j = 42; //  正确：可以为常量引用绑定字面值
```
### decltype和引用
```cpp
// decltype的结果可以是引用类型
int i = 42, *p = &i, &r = i;
decltype(r+0) b;  // 正确：加法的结果是int，因此b是一个(未初始化的)int
decltype(*p) c; //  错误:c是int&,必须初始化
```
因为r是一个引用，因此decltype(r)的结果是引用类型。如果想让结果类型是r所指的类型，可以把r作为表达式的一部分，如r+0，显然这个表达式的结果将是
一个具体值而非一个引用。  
另一方面，如果表达式的内容是解引用操作，则decltype将得到引用类型。正如我们所熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象，
而且还能给这个对象赋值。因此，`decltype(*p)`的结果类型就是int&,而非int.  
有一种情况需要特别注意:对于decltype所用的表达式来说，如果变量名叫上了一对括号，则得到的类型与不加括号时会有不同，如果decltype使用的是一个
不加括号的变量，则得到的结果就是该变量的类型：如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式。变量是一种可以作为复制语句左值
的特殊表达式，所以这样的decltype就会得到引用类型:
```cpp
//  decltype的表达式如果是加上了括号的变量，结果将是引用
decltype((i)) d;  //  错误:d是int&,必须初始化
decltype(i) e;  //  正确:e是一个(未初始化的)int
```
> decltype((variable))(注意是双层括号)的结果永远是引用，而decltype(varaiable)结果只有当varaiable本身就是一个引用时才是引用。  
题:
> 判断下列定义推断出的类型是什么，然后编写程序进行验证  
```cpp
const int i = 42;
auto j = i; const auto &k = i; auto *p = &i; 
const auto j2 = i, &k2 = i;
```
`j 是 int，k 是 const int的引用，p 是const int *，j2 是const int，k2 是 const int 的引用`
