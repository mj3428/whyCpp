# 变量与基本类型
## 变量
### 变量定义
初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义时把对象的当前值擦除，而以一个新值来替代。  
*例* double salary = wage = 9999.99;  
♥在这里 wage 是未定义的，应该在此之前将其定义。  
```
double wage;
double salary = wage = 9999.99;
```
另外提示:
> 使用未初始化的变量将带来无法预计的后果，有时我们足够幸运，以访问此类对象程序就崩溃并报错，此时只要找到崩溃的位置就很容易发现变量没被
初始化的问题。另外一些时候，程序会一直执行完并产生错误的结果。更糟糕的是，程序结果时对时错、无法把握。而且，往无关的位置添加代码还会导致
我们误以为程序对了，其实结果仍旧有错。  

### 变量声明和定义的关系
C++语言支持分离式编译机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。为了支持分离式编译，C++语言将声明和定义区分开来。**声明
（declaration）** 使得名字为程序所知，一个文件如果想使用别处定义的名字就必须包含对那个名字的声明。而**定义**负责创建与名字关联的实体。  
1. 变量声明规定了变量的类型和名字，在这一点上定义与之相同。  
2. 但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。  
关键字**extern** 是只声明而非定义。
```
extern int j;  // 声明i而非定义i
int j; //  声明并定义j
```
但是如果extern语句如果包含初始值就不再是声明，而变成了定义了:
`extern double pi = 3.1415; // 定义`  

⭐ 变量能且只能被定义一次，但是可以被多次声明  

⭐ C++是一种静态类型语言，其含义是在编译阶段检查类型。其中，检查类型的过程成为类型检查(type checking)

## 复合类型
### 指针
pointer是“指向point to”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。  
1. 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。  
2. 指针无须再定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。
#### 获取对象的地址
指针存放某个对象的地址，要想获取该地址，需要使用取地址符(操作符&):
`int *p = &ival;  // p存放变量ival的地址，或者说p是指向变量ival的指针`首先把p定义为一个指向int的指针，随后初始化p令其指向
名为ival的int对象。因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。  
其他所有指针的类型都要和它所指向的对象严格匹配:
```cpp
double dval;
double *pd = &dval; //  正确：初始值是double型对象的地址
double *pd2 = pd; //  正确：初始值是指向double对象的指针

int *pi = pd; //  错误:指针pi的类型和pd的类型不匹配
pi = &dval； //  错误:试图把double型对象的地址赋给int型指针
```
#### 利用指针访问对象
如果指针指向了一个对象，则允许使用**解引用符(操作符*)** 来访问该对象:
```
int ival = 42;
int *p = &ival; //  p存放着变量ival的地址，或者说p是指向变量ival的指针
cout << *p; //  由符号*得到指针p所指的对象，输出42
```
**关键概念**  
```cpp
//像&和*这样的符号,既能用作表达式里的运算符,也能作为声明的一部分出现,符号的上下文决定了符号的意义:

int i = 42;
int &r = i; //  &紧随类型名出现，因此是声明的一部分，r是一个引用
int *p; //  *紧随类型名出现，因此是声明的一部分，p是一个指针
p = &i; //  &出现在表达式中，是一个取地址符
*p = i; //  *出现在表达式中，是一个解引用符
int &r2 = *p; //  &是声明的一部分，*是一个解引用符
```
**建议：初始化所有指针**
> 在大多数编译器环境下,如果使用了未经初始化的指针,则该指针所占内存空间的当前内容将被看作一个地址值。访问该指针,相当于
去访问一个本不存在的位置上的本不存在的对象。糟糕的是,如果指针所占内存空间中恰好有内容,而这些内容又被当作了某个地址,我们就很难
分清它到底是合法的还是非法的了。  

#### 赋值和指针
指针和引用都能提供对其他对象的间接访问,然而在具体实现细节上二者有很大不同,其中最重要的一点就是引用本身并非一个对象。一旦定义了引
用,就无法令其再绑定到另外的对象,之后每次使用这个引用都是访问它最初绑定的那个对象。  
```cpp
int i = 42
int *pi = 0;  //  pi被初始化，但没有指向任何对象
int *pi2 = &i;  //  pi2被初始化，存有i的地址
int *pi3; //  如果pi3定义于块内，则pi3的值是无法确定的

pi3 = pi2 // pi3和pi2指向同一个对象i
pi2 = 0 //  现在pi2不指向任何对象了
```
有时候要想搞清楚一条赋值语句到底是改变了指针的值还是改变了指针所指对象的值不太容易，最好的办法就是记住赋值永远改变的是等号左侧的对象。  
比如:`pi = &ival; //  pi的值被改变，现在pi指向了ival`意思是为pi赋一个新值，也就是改变了哪个存放在pi内的地址值  
再如:`*pi = 0;  //  ival的值被改变，指针pi并没有改变`则`*pi`(也就是指针Pi指向的哪个对象)发生改变  
