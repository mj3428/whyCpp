# 指针、数组与引用
## 指针与const
* constexpr: 编译时求值  
* const:在当前作用域内，值不发生改变  

基本上，cosntexpr的作用是指示或确保在编译时求值，而const的主要任务是规定接口的不可修改性。  
很多对象的值一旦初始化就不会再改动：
- 使用符号化常量的代码比直接使用字面值常量的代码更易维护
- 我们经常通过指针读取数据，但是很少通过指针写入数据
- 绝大多数函数的参数只负责读取数据，很少写入数据  

为了表达一经初始化就不可修改的特性，我们可以在对象的定义中加上const关键字。
```
const int model = 90; //  model是一个const
const int v[] = {1,2,3,4};  //  v[i]是一个const
const int x;  //  错误:缺少初始化器
```
因为我们无法给const对象赋值，所以它必须初始化。一旦我们把某物声明成const,就确保它的值在其作用域内不会发生改变：
```
void f()
{
  model = 200;  //  错误
  v[2] = 3; //  错误
}
```
一个指针牵扯到两个对象:指针本身以及指针所指的对象。在指针的声明语句中“前置” const关键字将令所指的对象而非指针
本身成为常量。要想令指针本身成为常量,应该用`*const`代替普通的* .例如：
```
void f1(char* p)
{
  char s[] = "Gorm";
  
  const char* pc = s; //  指向常量的指针
  pc[3] = 'g';  //  错误:pc指向常量
  pc = p; //  ok
  
  char *const cp = s; //  常量指针
  cp[3] = 'a';  //OK
  cp = p; //  错误:cp是一个常量
  
  const char *const cpc = s;  //  指向常量的常量指针
  cpc[3] = 'a'; //  错误:cpc指向常量
  cpc = p;  //  错误:cpc本身是一个常量
}
```
声明运算符`*const`的作用是令指针本身称为常量。不存在形如`const*`的声明运算符，相反，出现在 * 前面的const是基本类型的一部分。例如：
```
char *const cp; //  指向char的常量指针
char const* pc; //  指向常量const的指针
const char* pc2;  //  指向常量char的指针
```
