# 类型转换
## 含有无符号类型的表达式
尽管我们不会故意给无符号对象赋一个负值，却可能（特别容易）写出这么做的代码。例如，当一个算术表达式中既有无符号数又有int值时，那个int值就会
转换成无符号数。把int转换成无符号数的过程和把int直接赋给无符号变量一样:
```
unsigned u = 10;
int i = -42;
std::cout << i + i << std::endl;  //  输出-84
std::cout << u + i << std::endl;  //  如果int占32位，输出4294967264
 ```
 在第一个输出表达式里，两个负整数相加并得到了期望的结果。在第二个输出表达式里，相加前首先把整数-42转换成无符号数。把负数转换成无符号数类似于
 直接给无符号数赋一个负值，结果等于这个负数加上无符号数的模。  
 
当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不能是一个负值：
```
unsigned u1 = 42, u2 = 10;
std::cout << u1 - u2 << std::endl; //  正确：输出32
std::cout << u2 - u1 << std::endl;  //  正确:不过，结果是取模后的值 
```

无符号数不会小于0这一事实同样关系到循环的写法.例如,中需要写一个循环，通过控制变量递减的方式把10到0的数字降序输出。这个循环可能类似于
下面的形式:
```
for (int i = 10; i >= 0; --i)
  std::cout << i << std::endl;
```
可能你会觉得反正也不打算输出负数，可以用无符号数来重写这个循环。然而，这个不经意的改变却意味着死循环:
```
for (unsigned u = 10; u >= 0; --u)
  std::cout << u << std::endl;
```
再看看当u等于0时发生了什么，这次迭代输出0，然后继续执行for语句里的表达式。表达式--u从i当中减去1，得到的结果-1并不满足无符号数的要求，此时
像所有表示范围之外的其他数字一样，-1被自动地转换成一个合法的无符号数。假设int类型占32位，则当u等于0时，--u的结果将会是4294967295。  
