# 类
## 类型转换
### 含有无符号类型的表达式
尽管我们不会故意给无符号对象赋一个负值，却可能（特别容易）写出这么做的代码。例如，当一个算术表达式中既有无符号数又有int值时，那个int值就会
转换成无符号数。把int转换成无符号数的过程和把int直接赋给无符号变量一样:
```
unsigned u = 10;
int i = -42;
std::cout << i + i << std::endl;  //  输出-84
std::cout << u + i << std::endl;  //  如果int占32位，输出4294967264
 ```
 在第一个输出表达式里，两个负整数相加并得到了期望的结果。在第二个输出表达式里，相加前首先把整数-42转换成无符号数。把负数转换成无符号数类似于
 直接给无符号数赋一个负值，结果等于这个负数加上无符号数的模。  
 
当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不能是一个负值：
```
unsigned u1 = 42, u2 = 10;
std::cout << u1 - u2 << std::endl; //  正确：输出32
std::cout << u2 - u1 << std::endl;  //  正确:不过，结果是取模后的值 
```

无符号数不会小于0这一事实同样关系到循环的写法.例如,中需要写一个循环，通过控制变量递减的方式把10到0的数字降序输出。这个循环可能类似于
下面的形式:
```
for (int i = 10; i >= 0; --i)
  std::cout << i << std::endl;
```
可能你会觉得反正也不打算输出负数，可以用无符号数来重写这个循环。然而，这个不经意的改变却意味着死循环:
```
for (unsigned u = 10; u >= 0; --u)
  std::cout << u << std::endl;
```
再看看当u等于0时发生了什么，这次迭代输出0，然后继续执行for语句里的表达式。表达式--u从i当中减去1，得到的结果-1并不满足无符号数的要求，此时
像所有表示范围之外的其他数字一样，-1被自动地转换成一个合法的无符号数。假设int类型占32位，则当u等于0时，--u的结果将会是4294967295。  
## 字面值常量
### 指定字面值的类型
可以改变整型、浮点型和字符型字面值的默认类型。
```
L'a' // 宽字符型字面值，类型是wchar_t
u8"hi!" // utf-8字符串字面值(utf-8用8位编码一个Unicode字符)
42ULL // 无符号整型字面值，类型是unsignded long long
1E-3F // 单精度浮点型字面值，类型是float
3.14159L // 扩展精度浮点型字面值，类型是long double
```
**当使用一个长整型字面值时，请使用大写字母L来标记，因为小写字母l和数字1太容易混淆了**   

> 下面两组定义是否有区别，如果有，请叙述之：
```
int month = 9, day = 7;
int month = 09, day = 07;
```
第一行定义的是十进制整型。 第二行定义的是八进制整型，但是 month 变量无效，因为八进制没有 9.  
