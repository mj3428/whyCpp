# 指针、数组与引用
在C++语言中存放及使用内存地址是通过指针和引用完成的
## 指针
对于类型T来说，T*是表示“指向T的指针”的类型。换句话说，T*类型的变量能存放T类型对象的地址，例如:
```
char c = 'a';
char* p = &c; //  p存放着c的地址，&是取地址运算符
```

对指针的一个基本操作是解引用，即引用地址所指的对象。这个操作也称为间接取值(indirection)。解引用运算符是个前置一元运算符，对应的符号是*,例如:
```
char c = 'a';
char* p = &c; //  p存放着c的地址，&是取地址运算符
char c2 = *p; //  c2 =='a'; *解引用运算符
```

指针p所指的对象是c，c中存储的值是'a'，因此我们把* p赋给c2等价于给c2赋值'a'。  
bool占用的内存空间至少和char一样多。如果想把更小的值存得更紧密，可以使用位逻辑操作、结构中的位域或者bitset  
符号 * 在用作类型名的后缀时表示"指向"的含义。如果我们想表示指向数组的指针或者指向函数的，需要使用稍微复杂一些的形式：
```
int* pi;  //  指向int的指针
char** ppc; //  指向字符指针的指针
int* ap[15];  //  ap是一个数组，包含15个指向int的指针
int (*fp)(char*); //  指向函数的指针，该函数接受一个char*实参，返回一个int
int* f(char*);  //  该函数接受一个char*实参，返回一个指向int的指针
```

### void* 
在某些偏向底层的代码中，我们偶尔需要在不知道对象确切类型的情况下，仅通过对象在内存中的地址存储或传递对象。此时，我们会用到void*.void* 的含义
是“指向未知类型对象的指针”。  
除了函数指针和指向类成员的指针,指向其他任意类型对象的指针都能被赋给一个void"类型的变量。此外,一个void"能被赋给另一个void",两个
" void* 能比较是否相等,我们还能把void"显式地转换成其他类型。因为编译器事实上并不清楚void"所指的对象到底是什么类型,所
以对它执行其他操作可能不太安全并且会引发编译器错误。要想使用void*,我们必须把它显式地转换成某一特定类型的指针。例如:
```
void f(int* pi)
{
  void* pv = pi;  //  ok:发生了从int*到void*的隐式类型转换
  *pv;  //  错误：不允许解引用void*
  ++pv; //  错误:不允许对void*执行递增操作(所指的对象尺寸未知)
  
  int* pi2 = static_cast<int*>(pv); //  显式转换回int*

  double* pd1 = pv; //  错误
  double* pd2 = pi; //  错误
  double* pd3 = static_cast<double*>(pv); //  不安全
}
```

### nullptr
字面常量nullptr表示空指针，即不指向任何对象的指针。我们可以把nullptr赋给其他任意指针类型，但是不能赋给其他内置类型:
```
int* pi = nullptr;
double* pd = nullptr;
int i = nullptr;  //  错误：i不是指针
```
nullptr只有一个，它可以用于任意指针类型。  
在C语言中，NULL通常是(void*)0,这种用法在C++中是非法的:`int* p = NULL; //  错误:不能把void*赋给int*`  

## 数组
