# 表达式
## 关于风格
例如，后置++的优先级高于一元* ,因此`*p++`的意思是`(p++)`而非`(*p)++`  
再比如，后置++的优先级高于一元 * ，所以`a+b*c` 的意思是`a+(b*c)`而非`(a+b)*c`  
一元运算符和赋值运算符是右结合的，其他所有运算符都是左结合。例如,a=b=c的意思是a=(b=c)，而a+b+c的意思是(a+b)+c  
## 运算符概述
### 结果
只要逻辑上说得通，对于接受左值运算对象的运算符来说，它的结果是一个表示该左值运算对象的左值，例如:
```
void f(int x,int y)
{
  int j = x = y;  //  x=y的值是x在执行赋值运算之后的结果值
  int* p = &++x;  //  p指向x
  int* q = &(x++);  //  错误:x++不是一个左值（它不是存储在x中的值）
  int* p2 = &(x>y?x:y)  //  具有较大值的地址
  int& r = (x<y)?x:1  //  错误：1不是左值
}
```
如果?:的第二个和第三个运算对象都是左值且类型相同,则该运算符的运算结果是一个同类型的左值。在这种方式下,左值的性质得以保留,因而在使用
运算符时拥有更大的灵活性。  
## 常量表达式
* constexpr:编译时求值  
* const:在作用域内不改变其值  
基本上，constexpr的作用是启用并确保编译时求值，而const的主要作用是在接口中规定某些成分不可修改。  
常量表达式是指由编译器求值的表达式。它不能包含任何编译时未知的值，也不能具有其他副作用。一条常量表达式由整数值、浮点数值或者枚举值等成分构成
，我们可以用运算或者生成常量值的constexpr函数把这些基本成分组合在一起。另外，某些常量表达式中还可以出现地址值。处于简化问题的考虑。  
### 常量表达式中的const
