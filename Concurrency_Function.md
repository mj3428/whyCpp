# 并发与实用功能
## 并发
### 任务和thread
我们可以构造一个std::thread并将任务作为它的实参。这里的任务是以函数或函数对象形式出现的:
```
void f(): //  函数
struct F{
  void operator()();  // F调用运算符
};

void user()
{
  thread t1 {f};  // f()在独立的线程中执行
  therad t2 {F()} //  F()()在独立的线程中执行
  
  t1.join();  // 等待t1完成  
  t2.join();  //  等待t2完成
}
```
join()保证我们在线程完成后才退出user(),其中"join"的意思是“等待线程结束"。一个程序的所有线程共享单一地址空间。在这一点上线程与
进程不同,进程间通常不直接共享数据。由于共享单一地址空间,因此线程间可通过共享对象相互通信。通常通过锁或其他防止数据竞争(对变量的
不受控制的并发访问)的机制来控制线程间通信。  
### 传递参数
任务通常需要处理数据，我们可以将数据（或指向数据的指针或引用）作为参数参数给任务，例如：
```
void f(vector<double>& v);  // 处理v的函数

struct F{ // 处理v的函数的对象
vector<double>& v;
F(vector<double>& vv) :v{vv}{}
void operator()(); // 调用运算符
};

int main()
{
  vector<double> some_vec{1,2,3,4,5,6,7,8,9};
  vector<double> vec2{10,11,12,13,14};
  
  thread t1 {f,some_vec}; //  f(some_vec)在一个独立线程中执行
  thread t2 {F{vec2}};  // F(vec2)()在一个独立线程中执行
  
  t1.join();
  t2.join();
}
```

显然, F{vec2)将一个指向参数(一个向量)的引用保存在F中。F现在就可以使用向量了,并希望在它运行的时候其他任务不会访问vec2————将
vec2以传值方式传递就可以消除这个风险。  
上面代码用{f,some-vec)初始化一个线程,它使用了thread的可变参数模板构造函数,接受一个任意的参数序列,编译器检查第一个参数(函数或函
数对象)是 ,否可用后续的参数来调用,如果检查通过,就构造一个必要的函数对象并传递给线程。因此, F::operator()与f()执行相同的算法,两个任
务的处理大致相同:它们都为thread构造了一个函数对象来执行任务。  

### 共享数据
有时任务间需要共享数据。此时数据访问必须进行同步,以确保在同一时刻至多有一个任务能访问数据。有经验的程序员可能认为这是
一种简单化的方法(例如,很多任务同时读取不变的数据是没有任何问题的),但无论如何,确保在同一时刻至多有一个任务可以访问给定的对象是很有意义的  
解决此问题的基础是"互斥对象"mutex。thread使用lock()操作来获取一个互斥对象:
```
mutex m; // 控制共享数据访问的mutex
int sh; // 共享的数据

void f()
{
  unique_lock<mutex> lck {m}; // 获取mutex
  sh+=7; // 处理共享数据
} // 隐式释放mutex
```

标准库提供了一个同时获取多个锁的操作，可以解决访问多个资源带来的死锁问题:
```
void f()
{
  // ...
  unique_lock<mutex> lck1 {m1,defer_lock};  // 推迟加锁:还为尝试获取mutex
  unique_lock<mutex> lck2 {m2,defer_lock};
  unique_lock<mutex> lck3 {m3,defer_lock};
  //...
  lock(lck1,lck2,lck3); // 获取全部三个锁
  //...处理共享数据..
} // 隐式释放所有mutex
```
lock()调用只有在获取了全部mutex实参后才会继续执行，当它持有mutex时，绝不会阻塞("睡眠")，当然也就不会导致死锁。unique_lock的析构函数
保证了当thread离开作用域时mutex会被释放.  
