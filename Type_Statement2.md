# 类与声明
## 声明
### 作用域(续)
在块内声明的名字能隐藏外层块及全局作用域中的同名声明。换句话说,一个已有的名字能快内被重新定义以指向另外,该名字恢复原来的含义。例如:  
```
int x;  //  全局变量 x
void f()
{
  int x;  //  局部变量x隐藏了全局变量x
  x = 1;  //  为局部变量x赋值
  {
    int x;  //  隐藏了上一个局部变量x
    x = 2;  //  为第二个局部变量x赋值
  }
  x = 3;  //  为第一个局部变量x赋值
}

int* p = &x;  //  获取全局变量x的地址
```

个名字被隐藏(或者说遮住, shadowed)的事实。由名字隐藏造成的程序错误不太多,因此·一旦出错极难发现。程序员应该尽量避免隐藏名字。
如果你给全局变量或者大函数中的局部于变量起类似于i或x的名字，无异于自找麻烦。  
我们可以使用作用域解析运算符::访问被隐藏了的全局名字，例如:
```
int x;
void f2()
{
  int x = 1;  //  隐藏全局变量x
  ::x = 2;  //  为全局变量x赋值
  x = 2;  //  为局部变量x赋值
}
```

有一种现象看起来有点奇怪，但却是合理的，即在同一个块内有可能同一个名字所指的是两个完全不同的实体，并且我们没有使用::运算符。例如:
```
int x = 11;
void f4() //  不合理:在同一个作用域内使用了两个名字都是x的对象
{
  int y = x;  //  使用全局变量x,结果是y=11
  
  int x = 22;
  y = x;  //  使用局部变量x,结果是y=22
}
```

我们通常认为函数的实参是生命在函数的最外层块中的，例如:
```
void f5(int x)
{
  int x;  //  错误
}
```
因为x在同一个作用域中定义了两次，所以上述程序存在错误.  
在for语句中引入的名字是该语句的局部名字(位于语句作用域内)。因此,在同一个函我们可以在好几个循环中使用同一个便于理解的名字。例如:
```
void f(vector<string>& v,list<int>& lst)
{
  for (vonst auto& x:v) cout << x << '\n';
  for (auto x:lst) cout << x <<'\n';
  for (int i = 0,i!=v.size(),++i) cout << v[i] << '\n';
  for (auto i:{1,2,3,4,5,6,7}) cout << i << '\n';
}
```

### 初始化
初始化防止窄化转换
```
void f(double val,int val2)
{
  int x2 = val; //  如果val==7.9,则x2的值变为7
  char c2 = val2; //  如果val2==1025,则c2的值变为1
  
  int x3 {val}; //  错误:可能发生截断
  char c3 {val2}; //  错误:可能发生窄化转换
  
  char c4{24};  //  ok 24能精确表达成一个char
  char c5{264}; //  错误（假定char占8位）：264不能表示成一个char
  
  int x4 {2.0}; //  错误：不允许double到int的类型转换
}
```

当我们使用auto关键字从初始化器推断变量的类型时，没必要采用列表初始化的方式。而且如果初始化器是{}列表，则推断得到的数据类型肯定不是我们想要
的结果。如：  
```
auto z1 {99}; //  z1的类型是initializer_list<int>
auto z2 = 99; //  z2的类型是int
```

当我们构建某些类的对象时，可能有两种形式：一种是提供一组初始值；另一组是提供几个实参，这些实参不一定是实际的存储的值，可能有别的含义。  
```
vector<int> v1 {99}; //  v1包含一个元素，该元素的值是99
vector<int> v2(99); //  v2包含99个元素，每个元素都取默认值0
```
空初始化器列表{}指定使用默认值进行初始化，例如:
```
int x4 {};  //  x4被赋值为0
double d4 {}; //  d4被赋值为0.0
char* p {}; //  p被赋值为nullptr
vector<int> v4{}; //  v4被赋值为一个空向量
string s4 {}; //  s4被赋值为""
```
