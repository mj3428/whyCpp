# 类与声明
## 声明
### 作用域(续)
在块内声明的名字能隐藏外层块及全局作用域中的同名声明。换句话说,一个已有的名字能快内被重新定义以指向另外,该名字恢复原来的含义。例如:  
```
int x;  //  全局变量 x
void f()
{
  int x;  //  局部变量x隐藏了全局变量x
  x = 1;  //  为局部变量x赋值
  {
    int x;  //  隐藏了上一个局部变量x
    x = 2;  //  为第二个局部变量x赋值
  }
  x = 3;  //  为第一个局部变量x赋值
}

int* p = &x;  //  获取全局变量x的地址
```

个名字被隐藏(或者说遮住, shadowed)的事实。由名字隐藏造成的程序错误不太多,因此·一旦出错极难发现。程序员应该尽量避免隐藏名字。
如果你给全局变量或者大函数中的局部于变量起类似于i或x的名字，无异于自找麻烦。  
我们可以使用作用域解析运算符::访问被隐藏了的全局名字，例如:
```
int x;
void f2()
{
  int x = 1;  //  隐藏全局变量x
  ::x = 2;  //  为全局变量x赋值
  x = 2;  //  为局部变量x赋值
}
```

有一种现象看起来有点奇怪，但却是合理的，即在同一个块内有可能同一个名字所指的是两个完全不同的实体，并且我们没有使用::运算符。例如:
```
int x = 11;
void f4() //  不合理:在同一个作用域内使用了两个名字都是x的对象
{
  int y = x;  //  使用全局变量x,结果是y=11
  
  int x = 22;
  y = x;  //  使用局部变量x,结果是y=22
}
```

我们通常认为函数的实参是生命在函数的最外层块中的，例如:
```
void f5(int x)
{
  int x;  //  错误
}
```
因为x在同一个作用域中定义了两次，所以上述程序存在错误.  
在for语句中引入的名字是该语句的局部名字(位于语句作用域内)。因此,在同一个函我们可以在好几个循环中使用同一个便于理解的名字。例如:
```
void f(vector<string>& v,list<int>& lst)
{
  for (vonst auto& x:v) cout << x << '\n';
  for (auto x:lst) cout << x <<'\n';
  for (int i = 0,i!=v.size(),++i) cout << v[i] << '\n';
  for (auto i:{1,2,3,4,5,6,7}) cout << i << '\n';
}
```

### 初始化
初始化防止窄化转换
```
void f(double val,int val2)
{
  int x2 = val; //  如果val==7.9,则x2的值变为7
  char c2 = val2; //  如果val2==1025,则c2的值变为1
  
  int x3 {val}; //  错误:可能发生截断
  char c3 {val2}; //  错误:可能发生窄化转换
  
  char c4{24};  //  ok 24能精确表达成一个char
  char c5{264}; //  错误（假定char占8位）：264不能表示成一个char
  
  int x4 {2.0}; //  错误：不允许double到int的类型转换
}
```

当我们使用auto关键字从初始化器推断变量的类型时，没必要采用列表初始化的方式。而且如果初始化器是{}列表，则推断得到的数据类型肯定不是我们想要
的结果。如：  
```
auto z1 {99}; //  z1的类型是initializer_list<int>
auto z2 = 99; //  z2的类型是int
```

当我们构建某些类的对象时，可能有两种形式：一种是提供一组初始值；另一组是提供几个实参，这些实参不一定是实际的存储的值，可能有别的含义。  
```
vector<int> v1 {99}; //  v1包含一个元素，该元素的值是99
vector<int> v2(99); //  v2包含99个元素，每个元素都取默认值0
```
空初始化器列表{}指定使用默认值进行初始化，例如:
```
int x4 {};  //  x4被赋值为0
double d4 {}; //  d4被赋值为0.0
char* p {}; //  p被赋值为nullptr
vector<int> v4{}; //  v4被赋值为一个空向量
string s4 {}; //  s4被赋值为""
```
如果你想对内置类型的局部变量或者用new创建的内置类型的对象执行初始化，使用{}的形式，例如：
```
void ff()
{
  int x{};  //  x的值变为0
  char buf[1024]{}; //  对于任意i，buf[i]的值变为0
  
  int* p {new int{10}}; //  *p的值变为10
  char* q {new char[1024]{}}; //  对于任意i，q[i]的值变为0
}
```

如果想显式地表达“执行默认初始化”的意愿，你需要使用{}。例如：
```
complex<double> z1(2,3);  //  函数风格的初始化器（用构造函数执行初始化）
complex<double> f1(); //  函数声明

complex<double> z2 {1,2};  //  用构造函数初始化成{1,2}
complex<double> f2 {};  //  用构造函数初始化成默认值{0,0}
```
#### 推断类型
两种机制:  
* **auto** 根据对象的初始化器推断对象的数据类型，可能是变量、const或者constexpr的类型  
* decltype(expr)推断的对象不是一个简单的初始化器，有可能是函数的返回类型或者类成员的类型  
我们可以为托短处的类型添加修饰符或说明符，比如const和&.例如：
```
void f(vector<int>& v)
{
  for (const auto& x:v){  //  x的类型是const int&
  }
}
```

在此例中，auto推断为v的元素的类型，即int.  
请注意，表达式的类型永远不会是引用类型，因为表达式会隐式地执行引用操作，例如：
```
void g(int& v)
{
  auto x = v;  //  x的类型是int,而不是int&
  auto& y = v;  //  y的类型是int&
}
```

事实上，当声明语句中有auto关键字时，=是比{}更好的选择，因为前者的结果可能并非我们所愿:
```
auto v1 {12345};  //  v1的类型是int的列表
auto v2 {'c'};  //  v2的类型是char的列表
auto v3 {f()};  //  v3是某种类型的列表
```
