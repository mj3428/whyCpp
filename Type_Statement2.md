# 类与声明
## 声明
### 作用域(续)
在块内声明的名字能隐藏外层块及全局作用域中的同名声明。换句话说,一个已有的名字能快内被重新定义以指向另外,该名字恢复原来的含义。例如:  
```
int x;  //  全局变量 x
void f()
{
  int x;  //  局部变量x隐藏了全局变量x
  x = 1;  //  为局部变量x赋值
  {
    int x;  //  隐藏了上一个局部变量x
    x = 2;  //  为第二个局部变量x赋值
  }
  x = 3;  //  为第一个局部变量x赋值
}

int* p = &x;  //  获取全局变量x的地址
```

个名字被隐藏(或者说遮住, shadowed)的事实。由名字隐藏造成的程序错误不太多,因此·一旦出错极难发现。程序员应该尽量避免隐藏名字。
如果你给全局变量或者大函数中的局部于变量起类似于i或x的名字，无异于自找麻烦。  
我们可以使用作用域解析运算符::访问被隐藏了的全局名字，例如:
```
int x;
void f2()
{
  int x = 1;  //  隐藏全局变量x
  ::x = 2;  //  为全局变量x赋值
  x = 2;  //  为局部变量x赋值
}
```

有一种现象看起来有点奇怪，但却是合理的，即在同一个块内有可能同一个名字所指的是两个完全不同的实体，并且我们没有使用::运算符。例如:
```
int x = 11;
void f4() //  不合理:在同一个作用域内使用了两个名字都是x的对象
{
  int y = x;  //  使用全局变量x,结果是y=11
  
  int x = 22;
  y = x;  //  使用局部变量x,结果是y=22
}
```

我们通常认为函数的实参是生命在函数的最外层块中的，例如:
```
void f5(int x)
{
  int x;  //  错误
}
```
因为x在同一个作用域中定义了两次，所以上述程序存在错误.  
在for语句中引入的名字是该语句的局部名字(位于语句作用域内)。因此,在同一个函我们可以在好几个循环中使用同一个便于理解的名字。例如:
```
void f(vector<string>& v,list<int>& lst)
{
  for (vonst auto& x:v) cout << x << '\n';
  for (auto x:lst) cout << x <<'\n';
  for (int i = 0,i!=v.size(),++i) cout << v[i] << '\n';
  for (auto i:{1,2,3,4,5,6,7}) cout << i << '\n';
}
```
### 初始化
