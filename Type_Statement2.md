# 类与声明
## 声明
### 作用域(续)
在块内声明的名字能隐藏外层块及全局作用域中的同名声明。换句话说,一个已有的名字能快内被重新定义以指向另外,该名字恢复原来的含义。例如:  
```
int x;  //  全局变量 x
void f()
{
  int x;  //  局部变量x隐藏了全局变量x
  x = 1;  //  为局部变量x赋值
  {
    int x;  //  隐藏了上一个局部变量x
    x = 2;  //  为第二个局部变量x赋值
  }
  x = 3;  //  为第一个局部变量x赋值
}

int* p = &x;  //  获取全局变量x的地址
```

个名字被隐藏(或者说遮住, shadowed)的事实。由名字隐藏造成的程序错误不太多,因此·一旦出错极难发现。程序员应该尽量避免隐藏名字。
如果你给全局变量或者大函数中的局部于变量起类似于i或x的名字，无异于自找麻烦。  
我们可以使用作用域解析运算符::访问被隐藏了的全局名字，例如:
```
int x;
void f2()
{
  int x = 1;  //  隐藏全局变量x
  ::x = 2;  //  为全局变量x赋值
  x = 2;  //  为局部变量x赋值
}
```

有一种现象看起来有点奇怪，但却是合理的，即在同一个块内有可能同一个名字所指的是两个完全不同的实体，并且我们没有使用::运算符。例如:
```
int x = 11;
void f4() //  不合理:在同一个作用域内使用了两个名字都是x的对象
{
  int y = x;  //  使用全局变量x,结果是y=11
  
  int x = 22;
  y = x;  //  使用局部变量x,结果是y=22
}
```

我们通常认为函数的实参是生命在函数的最外层块中的，例如:
```
void f5(int x)
{
  int x;  //  错误
}
```
因为x在同一个作用域中定义了两次，所以上述程序存在错误.  
在for语句中引入的名字是该语句的局部名字(位于语句作用域内)。因此,在同一个函我们可以在好几个循环中使用同一个便于理解的名字。例如:
```
void f(vector<string>& v,list<int>& lst)
{
  for (vonst auto& x:v) cout << x << '\n';
  for (auto x:lst) cout << x <<'\n';
  for (int i = 0,i!=v.size(),++i) cout << v[i] << '\n';
  for (auto i:{1,2,3,4,5,6,7}) cout << i << '\n';
}
```

### 初始化
初始化防止窄化转换
```
void f(double val,int val2)
{
  int x2 = val; //  如果val==7.9,则x2的值变为7
  char c2 = val2; //  如果val2==1025,则c2的值变为1
  
  int x3 {val}; //  错误:可能发生截断
  char c3 {val2}; //  错误:可能发生窄化转换
  
  char c4{24};  //  ok 24能精确表达成一个char
  char c5{264}; //  错误（假定char占8位）：264不能表示成一个char
  
  int x4 {2.0}; //  错误：不允许double到int的类型转换
}
```

当我们使用auto关键字从初始化器推断变量的类型时，没必要采用列表初始化的方式。而且如果初始化器是{}列表，则推断得到的数据类型肯定不是我们想要
的结果。如：  
```
auto z1 {99}; //  z1的类型是initializer_list<int>
auto z2 = 99; //  z2的类型是int
```

当我们构建某些类的对象时，可能有两种形式：一种是提供一组初始值；另一组是提供几个实参，这些实参不一定是实际的存储的值，可能有别的含义。  
```
vector<int> v1 {99}; //  v1包含一个元素，该元素的值是99
vector<int> v2(99); //  v2包含99个元素，每个元素都取默认值0
```
空初始化器列表{}指定使用默认值进行初始化，例如:
```
int x4 {};  //  x4被赋值为0
double d4 {}; //  d4被赋值为0.0
char* p {}; //  p被赋值为nullptr
vector<int> v4{}; //  v4被赋值为一个空向量
string s4 {}; //  s4被赋值为""
```
如果你想对内置类型的局部变量或者用new创建的内置类型的对象执行初始化，使用{}的形式，例如：
```
void ff()
{
  int x{};  //  x的值变为0
  char buf[1024]{}; //  对于任意i，buf[i]的值变为0
  
  int* p {new int{10}}; //  *p的值变为10
  char* q {new char[1024]{}}; //  对于任意i，q[i]的值变为0
}
```

如果想显式地表达“执行默认初始化”的意愿，你需要使用{}。例如：
```
complex<double> z1(2,3);  //  函数风格的初始化器（用构造函数执行初始化）
complex<double> f1(); //  函数声明

complex<double> z2 {1,2};  //  用构造函数初始化成{1,2}
complex<double> f2 {};  //  用构造函数初始化成默认值{0,0}
```
#### 推断类型
两种机制:  
* **auto** 根据对象的初始化器推断对象的数据类型，可能是变量、const或者constexpr的类型  
* decltype(expr)推断的对象不是一个简单的初始化器，有可能是函数的返回类型或者类成员的类型  
我们可以为托短处的类型添加修饰符或说明符，比如const和&.例如：
```
void f(vector<int>& v)
{
  for (const auto& x:v){  //  x的类型是const int&
  }
}
```

在此例中，auto推断为v的元素的类型，即int.  
请注意，表达式的类型永远不会是引用类型，因为表达式会隐式地执行引用操作，例如：
```
void g(int& v)
{
  auto x = v;  //  x的类型是int,而不是int&
  auto& y = v;  //  y的类型是int&
}
```

事实上，当声明语句中有auto关键字时，=是比{}更好的选择，因为前者的结果可能并非我们所愿:
```
auto v1 {12345};  //  v1的类型是int的列表
auto v2 {'c'};  //  v2的类型是char的列表
auto v3 {f()};  //  v3是某种类型的列表
```

## 对象和值
对象(object)是指一块连续存储区域,左值(Ivalue)是指向对象的一条表达式。“左值”的字面意思是“能用在赋值运算符左侧的东西”,但其实不是所有
左值都能用在赋值运算符的左侧,左值也有可能指示某个常量。
### 左值和右值
当考虑对象的寻址，拷贝，移动等操作时，有两种属性非常关键。
* **有身份（Has identity）：** 在程序中有对象的名字，或指向该对象的指针，或该对象的引用，这样我们就嗯呢该判断两个对象是否相等或者兑
  现的值是否发生了改变
* **可移动(Is movable):** 能把掉对象的内容移动出来 
### 对象的生命周期
* **自动(automatic)对象:** 除非特别说明，否则在函数声明的对象在其定义处被创建，当超出作用域范围时被销毁，这样的对象被称为自动对象。在大多数
  实现中，自动对象被分配在栈空间上。每调用一次函数，获取新的栈帧(stack frame)以存放它的自动对象。
* **静态(static)对象:** 在全局作用域或名字空间作用域中声明的对象以及在函数或类中声明的static成员只被创建并初始化一次，并且直到程序结束之前
  都“活着”。这样的对象被称为静态(static)对象。静态对象在程序的整个执行周期内地址唯一。在多线程环境中，静态对象可能会造成某些意料之外的问题。
  因为所有线程都共享静态对象，所以必须为其加锁以避免数据竞争。  
* **自由存储(free store)对象:**  用new和delete直接控制其生命周期的对象  
* **临时(temporary)对象：** 闭眼入计算的中间结果或用于存放const实参引用的值的对象。临时对象的生命周期由其用法决定。如果临时对象被绑定到
  一个引用上，则它的生命周期就是引用的生命周期；否则，临时对象的生命周期与它所处的完整表达式一致。其中，完整表达式(full expression)不属于任何
  其他表达式。通常情况下，临时对象也是自动对象。  
* **线程布局(thread-loacl)对象** 或者说声明为thread_local的对象：这样的对象随着线程的创建而创建，随着线程的销毁而销毁。  
静态和自动被称为存储类(storage class)  
数组元素和非静态类成员的生命周期由它们所属的对象决定  
### 类型别名
有时，我们需要为某种类型起个新名字。也有一方面是为了便于后期维护。  
例如:
```
using Pchar = char*;  //  字符串指针
using PF = int(*)(double);  //  函数指针，该函数接受一个double且返回一个int
相似类型可以定义同一个名字作为成员别名:
template<class T>
class vector{
  using value_type = T; // 每个容器都有一个value_type
};

template<class T>
class list{
  using value_type = T; //  每个容器都有一个value_type
};
```
无论如何，类型别名绝不代表一种新类型，它只是某种已有类型的同义词。换句话说，别名就是类型的另外一个名字而已。例如：
```
Pchar p1 = nullptr; //  pl的类型是char*
char* p3 = p1;  //  正确
```
